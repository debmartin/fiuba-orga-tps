\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}

\title{ \textbf{ 6620. Organizaci\'on de Computadoras\\
Trabajo Pr\'actico 0: \\
Infraestructura B\'asica}}

\author{	Riesgo, Daniela, \textit{Padr\'on Nro. 95557} \\
            	\texttt{ danielap.riesgo@gmail.com } \\[2.5ex]
            	Martin, D\'ebora, \textit{Padr\'on Nro. 90934} \\
            	\texttt{ debbie1mes.world@gmail.com } \\[2.5ex]
		Constantino, Guillermo, \textit{Padr\'on Nro. 89776} \\
		\texttt{ guilleconstantino@gmail.com } \\[2.5ex]
            	\normalsize{2do. Cuatrimestre de 2014} \\
            	\normalsize{66.20 Organizaci\'on de Computadoras  $-$ Pr\'atica Martes} \\
            	\normalsize{Facultad de Ingenier\'ia, Universidad de Buenos Aires} \\
       }

\date{}

\begin{document}
\maketitle
\thispagestyle{empty}  % quita el nmero en la primer pagina


\begin{abstract}
El presente trabajo tiene como objetivo familiarizarse con las herramientas de software que ser\'an usadas en los siguientes trabajos, implementando un programa en lenguaje C, y su correspondiente documentaci\'on, que resuelva el problema  planteado, que permita dibujar el conjunto de Mandelbrot y sus vecindades

\end{abstract}
\pagebreak



\setcounter{page}{2}
\section{Introducci\'on}
Al comenzar a utilizar nuevas herramientas, en cualquier \'ambito, es necesaria una breve introducci\'on al funcionamiento de las mismas: tener una noci\'on de las prestaciones que ofrecen, asi tambi\'en como de sus limitaciones.\\
Como primer objetivo en la materia, nos proponemos adentrarnos en el funcionamiento del emulador GXemul. Nuestra meta ser\'a emular una plataforma MIPS (ejecutando un sistema operativo NetBSD), para poder desde all\'i desarrollar programas en lenguaje C. Estos ser\'an compilados y ejecutados haciendo uso de la herramienta GCC (GNU Compiler Collection), mediante el cual tambi\'en ser\'a posible obtener, a posteriori, el c\'odigo MIPS32 del programa.\\
Una vez cumplido este objetivo, aprenderemos los rudimientos de \LaTeX{} para generar la documentaci\'on relevante al trabajo pr\'actico.

\pagebreak



\section{Programa a implementar}
Se trata de un disenar un programa que permita dibujar el conjunto de Mandelbrot y sus vecindades, en lenguaje C.
El mismo recibir\'a por l\'inea de comando, una serie de par\'ametros describiendo la regi\'on del
plano complejo y las caracter\'isticas del archivo imagen a generar. No deber\'a interactuar con
el usuario, ya que no se trata de un programa interactivo, sino m\'as bien de una herramienta
de procesamiento batch. Al finalizar la ejecuci\'on, y volver al sistema operativo, el programa
habr\'a  dibujado el fractal en el archivo de salida.
El formato gr\'afico a usar es PGM o portable gray map, un formato simple para describir im\'agenes a
 digitales monocrom\'aticas.

\pagebreak



\section{Explicaci\'on de la Implementaci\'on}
Las principales funciones y estructuras en nuestra implementaci\'on son las siguientes:

\subsection{main.c}


\subsubsection{main}
Esta funci\'on se encarga de procesar las opciones ingresadas por l\'inea de comando, verificando validez, e invocar a las funciones  seg\'un corresponda.

\subsubsection{generatePGM}
Genera la im\'agen PGM a partir de los valores de escape, que son insertados en la matriz que utiliza la funci\'on writePGM para generar dicha im\'agen.

\subsection{pgm.h}
Contiene la estructura b\'asica para generar una imagen del tipo PGM.

\subsubsection{writePGM}
Toma como par\'ametros el nombre de archivo, y una estructura PGM, la cual contiene: cantidad de filas y columnas, color de gris m\'aximo, y la matriz de pixeles.

\subsection{velocidad\_escape.h}
Este archivo maneja la estructura y operaciones entre n\'umeros complejos necesarias para obtener la velocidad de escape de uno.

\subsubsection{velocidad\_de\_escape}
Devuelve velocidad de escape seg\'un el complejo que reciba. Este valor define una intensidad seg\'un la condici\'on de corte.

\pagebreak



\section{Generaci\'on de ejecutables y c\'odigo assembly}
Para generar el ejecutable del programa, debe correrse la siguiente sentencia en una terminal:

\begin{verbatim}
$ gcc -Wall -pedantic --std=c99 -c velocidad_escape.c
$ gcc -Wall -pedantic --std=c99 -c pgm.c
$ gcc -Wall -pedantic --std=c99 velocidad_escape.o pgm.o main.c -o tp0
\end{verbatim}

Para generar el c\'odigo MIPS32, debe ejecutarse lo siguiente:
\begin{verbatim}
$ gcc -Wall -S -pedantic --std=c99 -c velocidad_escape.c
$ gcc -Wall -S -pedantic --std=c99 -c pgm.c
$ gcc -Wall -S -pedantic --std=c99 velocidad_escape.o pgm.o main.c -o tp0
\end{verbatim}

N\'otese que para ambos casos se han activado todos los mensajes de 'Warning' (-Wall). Adem\'as, para el caso de MIPS, se ha habilitado '-S', que detiene al compilador luego de generar el assembly.
\pagebreak




\section{Corridas de prueba}

En esta secci\'on se presentan algunas de las distintas corridas que se realizaron para probar el funcionamiento del trabajo pr\'actico.\\

1. Generamos una imagen de 1 punto de lado, centrada en el or\'igen del plano complejo:
\begin{verbatim}
> ./tp0 -c 0+0i -r 1x1 -o -
P2
1
1
255
255
\end{verbatim}

Notar que el resultado es correcto, ya que este punto pertenece al conjunto de Mandelbrot.\\
\\
2. Repetimos el experimento, pero nos centramos ahora en un punto que seguro no pertenece
al conjunto:
\begin{verbatim}
> ./tp0 -c 10+0i -r 1x1 -o -
P2
1
1
255
0
\end{verbatim}

Notar que el resultado es correcto, ya que este punto pertenece al conjunto de Mandelbrot.
\\
3. Imagen imposible:
\begin{verbatim}
> ./tp0 -c 0+0i -r 0x1 -o -
Usage:
  tp0 -h
  tp0 -V
: Undefined error: 0
\end{verbatim}


4. Archivo de salida imposible:
\begin{verbatim}
> ./tp0 -o /tmp
fatal: cannot open output file: is a directory
\end{verbatim}


5. Coordenadas complejas imposibles:
\begin{verbatim}
> ./tp0 -c 1+3 -o -
fatal: invalid center specification: Undefined error: 0
\end{verbatim}


6. Argumentos de l\'inea de comando vac\'ios,
\begin{verbatim}
> ./tp0 -c "" -o -
fatal: invalid center specification: Undefined error: 0
\end{verbatim}


Se adjunta imagen de la corrida de pruebas.
\begin{figure}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{pruebas.png}
    \label{fig:Resultado de correr los casos de prueba antes mencionados}
    \caption{}
  \end{center}
\end{figure}

7. Imagen PGM
\begin{verbatim}
> ./tp0 -o por_default.pgm
\end{verbatim}
Genera la siguiente imagen:
\begin{figure}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{por_default.png}
    \label{fig:Region barrida por defecto}
    \caption{}
  \end{center}
\end{figure}



8. Imagen PGM con regi\'on no centrada y un rect\'angulo de 0,005 unidades de lado.
\begin{verbatim}
> ./tp0 -c +0.282-0.01i -w 0.005 -H 0.005 -o zoom.pgm
\end{verbatim}
Genera la siguiente imagen:
\begin{figure}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{zoom.png}
    \label{fig:Region comprendida entre 0,2795 - 0,0075i y 0,2845 - 0,0125i}
    \caption{}
  \end{center}
\end{figure}


9. Se puede ver en la secci贸n del c贸digo fuente otras pruebas unitarias hechas para probar la funci贸n de velocidad de escape en el archivo pruebas_escape.c.
\begin{verbatim}
> gcc -Wall -pedantic --std=c99 velocidad_escape.o pruebas_escape.c -o prueba_escape
> ./prueba_escape
Vel de escape de 0+0i es 255: OK
Vel de escape de 10+0i es 0: OK
Vel de escape de -1+0i es 255: OK
Vel de escape de 0,5+0i es 4: OK
Vel de escape de 1+0i es 2: OK
\end{verbatim}

10. De la misma forma para pruebas unitarias respecto a la l贸gica del escalamiento de la imagen, se tiene el archivo pruebas_escala.c.
\begin{verbatim}
> gcc -Wall -pedantic --std=c99 velocidad_escape.o pruebas_escala.c -o prueba_escala
> ./prueba_escala
Complejos para -c 0+0i -r 2x2 -w 4 -H 4:
-1.000000 + 1.000000 i
1.000000 + 1.000000 i
-1.000000 + -1.000000 i
1.000000 + -1.000000 i
El primero es correcto: OK
El segundo es correcto: OK
El tercero es correcto: OK
El cuarto es correcto: OK
Complejos para -c 10+0i -r 1x1 -w 4 -H 4:
10.000000 + 0.000000 i
El primero es correcto: OK
Complejos para -c -3.5+1i -r 1x1 -w 4 -H 4:
-3.500000 + 1.000000 i
El primero es correcto: OK
Complejos para -c 1-3i -r 2x1 -w 2 -H 3:
0.500000 + -3.000000 i
1.500000 + -3.000000 i
El primero es correcto: OK
El segundo es correcto: OK
\end{verbatim}

\pagebreak


\section{C\'odigo fuente C}

\subsection{main.c}

\begin{verbatim}
#include <stdlib.h>
#include <getopt.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include "pgm.h"
#include "velocidad_escape.h"

#define DEFAULT_RESOLUTION_WIDTH 640
#define DEFAULT_RESOLUTION_HEIGHT 480
#define DEFAULT_CENTER_REAL 0
#define DEFAULT_CENTER_IMAG 0
#define DEFAULT_PLANE_WIDTH 4
#define DEFAULT_PLANE_HEIGHT 4
#define ARG_DEFAULT_OUT "-"


typedef struct _OutputData{
    int resolution[2];
    float center[2];
    float plane[2];
    FILE* output;
} OutputData;

void generatePGM(OutputData* data){
    PGMData pgm_image;
    pgm_image.row = data->resolution[1];
    pgm_image.col = data->resolution[0];
    pgm_image.max_gray = 255;
    pgm_image.matrix = allocate_dynamic_matrix(pgm_image.row, pgm_image.col);

    double first_real_value = data->center[0] - data->plane[0]/2;
    double first_imaginary_value = data->center[1] + data->plane[1]/2;
    double width_scale = (data->plane[0] / data->resolution[0]);
    double height_scale =  - (data->plane[1] / data->resolution[1]);
    first_real_value += width_scale/2;
    first_imaginary_value += height_scale/2;

    for(int i = 0; i < pgm_image.row; i++){
        for(int j = 0; j < pgm_image.col; j++){
            complejo* num = crear_complejo(first_real_value + j * width_scale, first_imaginary_value + i * height_scale);
            pgm_image.matrix[i][j] = velocidad_de_escape(num);
            destruir_complejo(num);
        }
    }

    writePGM(data->output, &pgm_image);
    deallocate_dynamic_matrix(pgm_image.matrix, pgm_image.row);
}

void OutputDataInitialize(OutputData* data){
    data->resolution[0] = DEFAULT_RESOLUTION_WIDTH;
    data->resolution[1] = DEFAULT_RESOLUTION_HEIGHT;
    data->center[0] = DEFAULT_CENTER_REAL;
    data->center[1] =  DEFAULT_CENTER_IMAG;
    data->plane[0] = DEFAULT_PLANE_WIDTH;
    data->plane[1] = DEFAULT_PLANE_HEIGHT;
    data->output = stdout;
}

int terminateError(char* errorMessaje){
    perror(errorMessaje);
    return 1;
}

int main(int argc, char* argv[]){
    static struct option long_options[] =
    {
        {"resolution", required_argument, 0, 'r'},
        {"center", required_argument, 0, 'c'},
        {"width", required_argument, 0, 'w'},
        {"height", required_argument, 0, 'H'},
        {"output", required_argument, 0, 'o'},
        {0, 0, 0, 0}
    };

    OutputData data;
    OutputDataInitialize(&data);
    bool need_close = false;
    char option, i;
    int option_index;

    while ((option = getopt_long(argc, argv, "o:r:c:w:H:", long_options, &option_index)) != -1) {
        switch (option){
            case 'r':
                if (sscanf(optarg, "%d%*c%d", &data.resolution[0], &data.resolution[1]) != 2){
                    return terminateError("fatal: invalid resolution specification");
                }
                if (data.resolution[0] <= 0 || data.resolution[1] <= 0){
                    return terminateError("Usage:\n\ttp0 -h\n\ttp0 -V\n");
                }
                break;
            case 'c':
                if (sscanf(optarg, "%f%*c%f%c", &data.center[0], &data.center[1], &i) != 3 || i!='i'){
                    return terminateError("fatal: invalid center specification");
                }
                break;
            case 'w':
                data.plane[0] = atof(optarg);
                if (data.plane[0] <= 0){
                    return terminateError("fatal: invalid width specification");
                }
                break;
            case 'H':
                data.plane[1] = atof(optarg);
                if (data.plane[1] <= 0){
                    return terminateError("fatal: invalid height specification");
                }
                break;
            case 'o':
                if (strcmp(ARG_DEFAULT_OUT, optarg) != 0){
                    data.output = fopen(optarg, "w");
                    if (! data.output){
                        return terminateError("fatal: cannot open output file");
                    }
                    need_close = true;
                }
                break;
            default:
                return terminateError("fatal: invalid arguments");
        }
    }
    generatePGM(&data);
    if (need_close) fclose(data.output);
    return 0;
}

\end{verbatim}
\pagebreak

\subsection{pgm.c}

\begin{verbatim}
// Based on http://zerocool.is-a-geek.net/simd-instructions-in-c-part-two/

#include "pgm.h"


#define HI(num)	(((num) & 0x0000FF00) >> 8)
#define LO(num)	((num) & 0x000000FF)

int **allocate_dynamic_matrix(int row, int col) {

	int **ret_val;
	int i;

	ret_val = (int **) malloc(sizeof(int *) * row);
	if (ret_val == NULL) {
		perror("memory allocation failure");
		exit(EXIT_FAILURE);
	}

	for (i = 0; i < row; ++i) {
		ret_val[i] = (int *) malloc(sizeof(int) * col);
		if (ret_val[i] == NULL) {
			perror("memory allocation failure");
			exit(EXIT_FAILURE);
		}
	}

	return ret_val;
}

void deallocate_dynamic_matrix(int **matrix, int row) {

	int i;

	for (i = 0; i < row; ++i)
		free(matrix[i]);
	free(matrix);
}

void SkipComments(FILE *fp) {

	int ch;
	char line[100];

	while ((ch = fgetc(fp)) != EOF && isspace(ch))
		;
	if (ch == '#') {
		fgets(line, sizeof(line), fp);
		SkipComments(fp);
	} else
		fseek(fp, -1, SEEK_CUR);

}

void writePGM(FILE *pgmFile, const PGMData *data) {
	int i, j;
	int lo;

	fprintf(pgmFile, "P2\n");
	fprintf(pgmFile, "%d\n%d\n", data->col, data->row);
	fprintf(pgmFile, "%d\n", data->max_gray);

	for (i = 0; i < data->row; ++i){
		for (j = 0; j < data->col; ++j) {
            fprintf(pgmFile, "%d ", data->matrix[data->row - i-1][j]);
		}
		fprintf(pgmFile, "\n");
	}
}

\end{verbatim}
\pagebreak

\subsection{velocidad\_escape.c}

\begin{verbatim}
#include <stdlib.h>
#include <stddef.h>
#include <math.h>
#include <complex.h>

#include "velocidad_escape.h"

#define N 256

typedef struct num_complejo {
	double real;
	double imaginario;
} complejo;

complejo* crear_complejo(double real, double imaginaria) {
	complejo* num = malloc(sizeof(complejo));
	if (num == NULL)
		return NULL;
	num->real = real;
	num->imaginario = imaginaria;
	return num;
}

void destruir_complejo(complejo* num) {
	free(num);
}

unsigned int modulo_al_2(complejo* num) {
	return (num->real * num->real) + (num->imaginario * num->imaginario);
}

complejo* sumar(complejo* num1, complejo* num2) {
	double real = num1->real + num2->real;
	double imaginario = num1->imaginario + num2->imaginario;
	return crear_complejo(real, imaginario);
}

complejo* al_2(complejo* num) {
	double real = num->real * num->real - num->imaginario * num->imaginario;
	double imaginario = 2 * num->real * num->imaginario;
	return crear_complejo(real, imaginario);
}

int velocidad_de_escape(complejo* num) {
	complejo* num2 = crear_complejo(num->real, num->imaginario);
	int i;
	for (i = 0; i < (N - 1); ++i) {
		if (modulo_al_2(num2) > 4)
			break;
		num2 = sumar(al_2(num2), num);
	}
	return i;
}

\end{verbatim}



\subsection{pruebas_escala.c}
\begin{verbatim}
#include <stdio.h>
#include "velocidad_escape.h"

void imprimir_complejos_del_plano(double centro_real, double centro_imag, double ancho_plano, double alto_plano, int ancho_res, int alto_res, double* v){
	
	double first_real_value = centro_real - ((float)ancho_plano)/2;
    double first_imaginary_value = centro_imag + ((float)alto_plano)/2;
    double width_scale = (((float) ancho_plano) / ancho_res);
    double height_scale =  - (((float) alto_plano) / alto_res);
    first_real_value += width_scale/2;
    first_imaginary_value += height_scale/2;
    
	int contador = 0;
    for(int i = 0; i < alto_res; i++){
        for(int j = 0; j < ancho_res; j++){
			double real = first_real_value + j * width_scale;
			double imag = first_imaginary_value + i * height_scale;
			
			printf("%f + %f i\n", real, imag);
			
			v[contador] = real;
			contador++;
			v[contador] = imag;
			contador++;
		}
	}

}

int main(){

	printf("Complejos para -c 0+0i -r 2x2 -w 4 -H 4:\n");
    double v1[8];
    imprimir_complejos_del_plano(0, 0, 4, 4, 2, 2, v1);
	printf("El primero es correcto: %s\n", ((v1[0] == -1) & (v1[1] == 1))? "OK" : "ERROR");
	printf("El segundo es correcto: %s\n", ((v1[2] == 1) & (v1[3] == 1))? "OK" : "ERROR");
	printf("El tercero es correcto: %s\n", ((v1[4] == -1) & (v1[5] == -1))? "OK" : "ERROR");
	printf("El cuarto es correcto: %s\n", ((v1[6] == 1) & (v1[7] == -1))? "OK" : "ERROR");
	
	printf("Complejos para -c 10+0i -r 1x1 -w 4 -H 4:\n");
    double v2[2];
    imprimir_complejos_del_plano(10, 0, 4, 4, 1, 1, v2);
	printf("El primero es correcto: %s\n", ((v2[0] == 10) & (v2[1] == 0))? "OK" : "ERROR");
	
	printf("Complejos para -c -3.5+1i -r 1x1 -w 4 -H 4:\n");
    double v3[2];
    imprimir_complejos_del_plano(-3.5, 1, 4, 4, 1, 1, v3);
	printf("El primero es correcto: %s\n", ((v3[0] == - 3.5) & (v3[1] == 1))? "OK" : "ERROR");
	
	printf("Complejos para -c 1-3i -r 2x1 -w 2 -H 3:\n");
    double v4[4];
    imprimir_complejos_del_plano(1, -3, 2, 3, 2, 1, v4);
	printf("El primero es correcto: %s\n", ((v4[0] == 0.5) & (v4[1] == -3))? "OK" : "ERROR");
	printf("El segundo es correcto: %s\n", ((v4[2] == 1.5) & (v4[3] == -3))? "OK" : "ERROR");
	
	return 0;
}

\end{verbatim}


\subsection{pruebas_escala.c}
\begin{verbatim}
#include <stdio.h>
#include "velocidad_escape.h"

int main(){
	pixel_t* pixel1 = crear_pixel(0, 0);
	int vel1 = velocidad_de_escape(pixel1);
	printf("%s: %s\n", "Vel de escape de 0+0i es 255", (vel1 == 255)? "OK" : "ERROR");

	pixel_t* pixel2 = crear_pixel(10, 0);
	int vel2 = velocidad_de_escape(pixel2);
	printf("%s: %s\n", "Vel de escape de 10+0i es 0", (vel2 == 0)? "OK" : "ERROR");
	
   pixel_t* pixel3 = crear_pixel(-1, 0);
	int vel3 = velocidad_de_escape(pixel3);
	printf("%s: %s\n", "Vel de escape de -1+0i es 255", (vel3 == 255)? "OK" : "ERROR");
	
	pixel_t* pixel4 = crear_pixel(0.5, 0);
	int vel4 = velocidad_de_escape(pixel4);
	printf("%s: %s\n", "Vel de escape de 0,5+0i es 4", (vel4 == 4)? "OK" : "ERROR");
	
	pixel_t* pixel5 = crear_pixel(1, 0);
	int vel5 = velocidad_de_escape(pixel5);
	printf("%s: %s\n", "Vel de escape de 1+0i es 2", (vel5 == 2)? "OK" : "ERROR");
}

\end{verbatim}

\pagebreak



\section{Conclusiones}
El trabajo pr\'activo motivo de este informe ha presentado al equipo diversos desaf\'ios. En primer lugar cabe mencionar la adaptaci\'on a un ambiente basado en GNU/Linux, no dominado por todos sus integrantes de igual manera. Tambi\'en es destacable la dificultad inicial que trajo la correcta configuraci\'on del ambiente virtual utilizado para emular la m\'aquina MIPS. Finalmente, tambi\'en fue invertida una cantidad considerable de tiempo en aprender a utilizar e investigar sobre archivos PGM y principalmente \LaTeX{}, ya que si bien permite obtener muy buenos resultados, se requiere de mucha lectura para poder aprovechar todo su potencial.
Por las razones expuestas, consideramos muy necesario un trabajo pr\'actico introductorio de esta naturaleza, para nivelar e introducir los elementos a utilizar en las dem\'as actividades pr\'acticas que se desarrollar\'an en el curso.\\
Como conclusi\'on final, podemos considerar que hemos logrado obtener un buen manejo de las herramientas introducidas en este primer proyecto.

\pagebreak

\begin{thebibliography}{99}
	
\bibitem{GXEMUL} GXemul, http://gxemul.sourceforge.net/

\bibitem{NETBSD} The NetBSD Project, http://www.netbsd.org/

\bibitem{MANDEL} Mandelbrot, http://en.wikipedia.org/wiki/Mandelbrot\_set/

\bibitem{MANSET}  Introduction to the Mandelbrot Set,
http://www.olympus.net/personal/dewey/mandelbrot.html.

\bibitem{MANEXT} Smooth shading for the Mandelbrot exterior.
http://linas.org/art-gallery/escape/smooth.html. Linas Vepstas. October, 1997.

\bibitem{PGMFORMAT} PGM format specification.
http://netpbm.sourceforge.net/doc/pgm.html.

\bibitem{LATEX} Oetiker, Tobias, "The Not So Short Introduction To LaTeX2", http://www.physics.udel.edu/$\sim$dubois/lshort2e/

\end{thebibliography}


\end{document}
